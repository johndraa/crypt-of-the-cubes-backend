


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > WorldLevelManager</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">survivor.runtime</a>
</div>

<h1>Coverage Summary for Class: WorldLevelManager (survivor.runtime)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">WorldLevelManager</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (17/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.4%
  </span>
  <span class="absValue">
    (27/32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    96.5%
  </span>
  <span class="absValue">
    (82/85)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package survivor.runtime;
&nbsp;
&nbsp;import survivor.combat.Stats;
&nbsp;import survivor.combat.Vec2;
&nbsp;import survivor.model.EnemyState;
&nbsp;import survivor.model.EnemyType;
&nbsp;import survivor.model.PlayerState;
&nbsp;
&nbsp;import java.util.Collection;
&nbsp;import java.util.List;
&nbsp;import java.util.SplittableRandom;
&nbsp;import java.util.function.IntSupplier;
&nbsp;
&nbsp;/**
&nbsp; * World-level / wave manager (per MatchRuntime).
&nbsp; *
&nbsp; * - Tracks currentWorldLevel, remainingEnemiesInWave, totalEnemiesThisWave.
&nbsp; * - Spawns full waves at the start of each world level.
&nbsp; * - Increases enemy count per wave up to a hard cap (250).
&nbsp; * - After cap, keeps count fixed and applies stat scaling instead.
&nbsp; *
&nbsp; * Integrates with:
&nbsp; * - MatchRuntime.start()      -&gt; startFirstWave(...)
&nbsp; * - MatchRuntime.tick()       -&gt; handleDeaths(...), may advance to next wave
&nbsp; *
&nbsp; * Does NOT touch:
&nbsp; * - match end / DB persistence / XP pipelines.
&nbsp; */
<b class="fc">&nbsp;public class WorldLevelManager {</b>
&nbsp;
&nbsp;    private static final int MAP_W = 2000;
&nbsp;    private static final int MAP_H = 2000;
&nbsp;
&nbsp;    /** Max enemies spawned per wave. */
&nbsp;    private static final int WAVE_SPAWN_CAP = 250;
&nbsp;
&nbsp;    /** Optional safety buffer around players (px). */
&nbsp;    private static final double SAFE_PLAYER_RADIUS = 100.0;
&nbsp;
<b class="fc">&nbsp;    private final SplittableRandom rng = new SplittableRandom();</b>
&nbsp;
<b class="fc">&nbsp;    private int currentWorldLevel = 1;</b>
<b class="fc">&nbsp;    private int remainingEnemiesInWave = 0;</b>
<b class="fc">&nbsp;    private int totalEnemiesThisWave = 0;</b>
&nbsp;
&nbsp;    /** First world level at which spawn count hit the cap; null until then. */
<b class="fc">&nbsp;    private Integer levelWhereCapReached = null;</b>
&nbsp;
<b class="fc">&nbsp;    private boolean active = false;</b>
&nbsp;
&nbsp;    // Base stats copied from old MatchRuntime.spawnInitial()
<b class="fc">&nbsp;    private static final Stats BUMPER_BASE = new Stats(</b>
&nbsp;            /*health*/60, /*moveSpeed*/30, /*attackSpeed*/10,
&nbsp;            /*damageMult*/3, /*critChance*/2, /*range*/5
&nbsp;    );
<b class="fc">&nbsp;    private static final Stats SWIPER_BASE = new Stats(</b>
&nbsp;            /*health*/80, /*moveSpeed*/28, /*attackSpeed*/15,
&nbsp;            /*damageMult*/5, /*critChance*/3, /*range*/7
&nbsp;    );
&nbsp;    private static final double ENEMY_RADIUS = 12.0;
&nbsp;
&nbsp;    /**
&nbsp;     * Initialize wave progression at world level 1 and spawn the first wave.
&nbsp;     * Called once from MatchRuntime.start().
&nbsp;     */
&nbsp;    public void startFirstWave(List&lt;EnemyState&gt; enemies,
&nbsp;                               Collection&lt;PlayerState&gt; players,
&nbsp;                               IntSupplier idGenerator) {
<b class="fc">&nbsp;        currentWorldLevel = 1;</b>
<b class="fc">&nbsp;        active = true;</b>
<b class="fc">&nbsp;        spawnWave(enemies, players, idGenerator);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Called once per tick from MatchRuntime.tick(), after CombatResolve.apply().
&nbsp;     *
&nbsp;     * @param deaths           combat death events for this tick
&nbsp;     * @param enemies          shared enemy list for the match
&nbsp;     * @param players          current players in the match
&nbsp;     * @param idGenerator      generator for unique enemy ids
&nbsp;     * @param matchEndingSoon  true if this tick has determined the match should end
&nbsp;     *                         (in which case we do NOT spawn a new wave)
&nbsp;     */
&nbsp;    public void handleDeaths(List&lt;CombatResolve.DeathEvent&gt; deaths,
&nbsp;                             List&lt;EnemyState&gt; enemies,
&nbsp;                             Collection&lt;PlayerState&gt; players,
&nbsp;                             IntSupplier idGenerator,
&nbsp;                             boolean matchEndingSoon) {
<b class="pc">&nbsp;        if (!active) return;</b>
&nbsp;
<b class="fc">&nbsp;        long enemyDeaths = deaths.stream()</b>
<b class="fc">&nbsp;                .filter(d -&gt; &quot;enemy&quot;.equals(d.type()))</b>
<b class="fc">&nbsp;                .count();</b>
<b class="fc">&nbsp;        if (enemyDeaths == 0) return;</b>
&nbsp;
<b class="pc">&nbsp;        if (remainingEnemiesInWave &gt; 0) {</b>
<b class="fc">&nbsp;            remainingEnemiesInWave -= enemyDeaths;</b>
<b class="pc">&nbsp;            if (remainingEnemiesInWave &lt; 0) remainingEnemiesInWave = 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        // When current wave is cleared, immediately start the next world level,
&nbsp;        // unless the match is about to end.
<b class="fc">&nbsp;        if (remainingEnemiesInWave == 0 &amp;&amp; !matchEndingSoon) {</b>
<b class="fc">&nbsp;            currentWorldLevel++;</b>
<b class="fc">&nbsp;            spawnWave(enemies, players, idGenerator);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    // -------------------- Internals --------------------
&nbsp;
&nbsp;    /**
&nbsp;     * Compute and spawn the full wave for currentWorldLevel.
&nbsp;     */
&nbsp;    private void spawnWave(List&lt;EnemyState&gt; enemies,
&nbsp;                           Collection&lt;PlayerState&gt; players,
&nbsp;                           IntSupplier idGenerator) {
&nbsp;
<b class="fc">&nbsp;        int spawnCount = computeSpawnCount(currentWorldLevel);</b>
<b class="fc">&nbsp;        totalEnemiesThisWave = spawnCount;</b>
<b class="fc">&nbsp;        remainingEnemiesInWave = spawnCount;</b>
&nbsp;
&nbsp;        // Remember the first level at which we hit the cap,
&nbsp;        // for use in the scaling functions.
<b class="fc">&nbsp;        if (spawnCount &gt;= WAVE_SPAWN_CAP &amp;&amp; levelWhereCapReached == null) {</b>
<b class="fc">&nbsp;            levelWhereCapReached = currentWorldLevel;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Simple composition: 75% bumpers, 25% swipers (at least 1 swiper if possible)
<b class="fc">&nbsp;        int numSwipers = Math.max(1, spawnCount / 4);</b>
<b class="fc">&nbsp;        int numBumpers = spawnCount - numSwipers;</b>
&nbsp;
&nbsp;        // Spawn bumpers
<b class="fc">&nbsp;        for (int i = 0; i &lt; numBumpers; i++) {</b>
<b class="fc">&nbsp;            Vec2 pos = randomSpawnPosition(players);</b>
<b class="fc">&nbsp;            Stats stats = scaledStats(BUMPER_BASE);</b>
<b class="fc">&nbsp;            int hp = scaledHealth(BUMPER_BASE);</b>
&nbsp;
<b class="fc">&nbsp;            enemies.add(new EnemyState(</b>
<b class="fc">&nbsp;                    idGenerator.getAsInt(),</b>
&nbsp;                    pos,
&nbsp;                    stats,
&nbsp;                    hp,
&nbsp;                    EnemyType.BUMPER,
&nbsp;                    ENEMY_RADIUS
&nbsp;            ));
&nbsp;        }
&nbsp;
&nbsp;        // Spawn swipers
<b class="fc">&nbsp;        for (int i = 0; i &lt; numSwipers; i++) {</b>
<b class="fc">&nbsp;            Vec2 pos = randomSpawnPosition(players);</b>
<b class="fc">&nbsp;            Stats stats = scaledStats(SWIPER_BASE);</b>
<b class="fc">&nbsp;            int hp = scaledHealth(SWIPER_BASE);</b>
&nbsp;
<b class="fc">&nbsp;            enemies.add(new EnemyState(</b>
<b class="fc">&nbsp;                    idGenerator.getAsInt(),</b>
&nbsp;                    pos,
&nbsp;                    stats,
&nbsp;                    hp,
&nbsp;                    EnemyType.SWIPER,
&nbsp;                    ENEMY_RADIUS
&nbsp;            ));
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Spawn count formula:
&nbsp;     *   wave N spawn = min(20 + (N - 1) * 10, WAVE_SPAWN_CAP)
&nbsp;     */
&nbsp;    private int computeSpawnCount(int wave) {
<b class="fc">&nbsp;        int base = 20 + (wave - 1) * 10;</b>
<b class="fc">&nbsp;        return Math.min(base, WAVE_SPAWN_CAP);</b>
&nbsp;    }
&nbsp;
&nbsp;    private int scaledHealth(Stats base) {
<b class="fc">&nbsp;        double hpMult = computeHpMultiplier();</b>
<b class="fc">&nbsp;        return (int) Math.round(base.health() * hpMult);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Build a scaled Stats record applying HP, damage, and move speed scaling.
&nbsp;     * Other fields (attackSpeed, critChance, range) are left as-is for now.
&nbsp;     */
&nbsp;    private Stats scaledStats(Stats base) {
<b class="fc">&nbsp;        double hpMult = computeHpMultiplier();</b>
<b class="fc">&nbsp;        double dmgMult = computeDamageMultiplier();</b>
<b class="fc">&nbsp;        double speedMult = computeSpeedMultiplier();</b>
&nbsp;
<b class="fc">&nbsp;        int health      = (int) Math.round(base.health()      * hpMult);</b>
<b class="fc">&nbsp;        int moveSpeed   = (int) Math.round(base.moveSpeed()   * speedMult);</b>
<b class="fc">&nbsp;        int attackSpeed = base.attackSpeed();</b>
<b class="fc">&nbsp;        int damageMult  = (int) Math.round(base.damageMult()  * dmgMult);</b>
<b class="fc">&nbsp;        int critChance  = base.critChance();</b>
<b class="fc">&nbsp;        int range       = base.range();</b>
&nbsp;
<b class="fc">&nbsp;        return new Stats(health, moveSpeed, attackSpeed, damageMult, critChance, range);</b>
&nbsp;    }
&nbsp;
&nbsp;    // -------- global scaling curve (after spawn cap is reached) --------
&nbsp;
&nbsp;    private int computeScaleLevel() {
<b class="fc">&nbsp;        if (levelWhereCapReached == null) return 0;</b>
<b class="fc">&nbsp;        return Math.max(0, currentWorldLevel - levelWhereCapReached);</b>
&nbsp;    }
&nbsp;
&nbsp;    private double computeHpMultiplier() {
<b class="fc">&nbsp;        int scaleLevel = computeScaleLevel();</b>
<b class="fc">&nbsp;        return 1.0 + 0.10 * scaleLevel;</b>
&nbsp;    }
&nbsp;
&nbsp;    private double computeDamageMultiplier() {
<b class="fc">&nbsp;        int scaleLevel = computeScaleLevel();</b>
<b class="fc">&nbsp;        return 1.0 + 0.08 * scaleLevel;</b>
&nbsp;    }
&nbsp;
&nbsp;    private double computeSpeedMultiplier() {
<b class="fc">&nbsp;        int scaleLevel = computeScaleLevel();</b>
<b class="fc">&nbsp;        return 1.0 + 0.05 * scaleLevel;</b>
&nbsp;    }
&nbsp;
&nbsp;    // -------- spawn positioning (respects 2000x2000 map + optional safe radius) --------
&nbsp;
&nbsp;    private Vec2 randomSpawnPosition(Collection&lt;PlayerState&gt; players) {
<b class="fc">&nbsp;        final int maxAttempts = 10;</b>
&nbsp;
<b class="pc">&nbsp;        for (int i = 0; i &lt; maxAttempts; i++) {</b>
<b class="fc">&nbsp;            double x = rng.nextDouble(0, MAP_W);</b>
<b class="fc">&nbsp;            double y = rng.nextDouble(0, MAP_H);</b>
<b class="fc">&nbsp;            Vec2 candidate = new Vec2(x, y);</b>
&nbsp;
<b class="fc">&nbsp;            if (isSafeFromPlayers(candidate, players)) {</b>
<b class="fc">&nbsp;                return candidate;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Fallback: just return a random point if we couldn&#39;t find a safe one.
<b class="nc">&nbsp;        double x = rng.nextDouble(0, MAP_W);</b>
<b class="nc">&nbsp;        double y = rng.nextDouble(0, MAP_H);</b>
<b class="nc">&nbsp;        return new Vec2(x, y);</b>
&nbsp;    }
&nbsp;
&nbsp;    private boolean isSafeFromPlayers(Vec2 pos, Collection&lt;PlayerState&gt; players) {
<b class="fc">&nbsp;        double r2 = SAFE_PLAYER_RADIUS * SAFE_PLAYER_RADIUS;</b>
&nbsp;
<b class="fc">&nbsp;        for (PlayerState p : players) {</b>
<b class="pc">&nbsp;            if (p == null) continue;</b>
<b class="fc">&nbsp;            double dx = pos.x() - p.pos().x();</b>
<b class="fc">&nbsp;            double dy = pos.y() - p.pos().y();</b>
<b class="fc">&nbsp;            if (dx * dx + dy * dy &lt; r2) {</b>
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    // -------- read-only diagnostics --------
&nbsp;
&nbsp;    public int getCurrentWorldLevel() {
<b class="fc">&nbsp;        return currentWorldLevel;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getRemainingEnemiesInWave() {
<b class="fc">&nbsp;        return remainingEnemiesInWave;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int getTotalEnemiesThisWave() {
<b class="fc">&nbsp;        return totalEnemiesThisWave;</b>
&nbsp;    }
&nbsp;}
&nbsp;
&nbsp;
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-12-08 17:10</div>
</div>
</body>
</html>
