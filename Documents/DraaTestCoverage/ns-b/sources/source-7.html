


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > TickService</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">survivor.runtime</a>
</div>

<h1>Coverage Summary for Class: TickService (survivor.runtime)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TickService</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    53.1%
  </span>
  <span class="absValue">
    (34/64)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    56.8%
  </span>
  <span class="absValue">
    (71/125)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package survivor.runtime;
&nbsp;
&nbsp;import lombok.RequiredArgsConstructor;
&nbsp;import org.springframework.beans.factory.annotation.Value;
&nbsp;import org.springframework.scheduling.annotation.Scheduled;
&nbsp;import org.springframework.stereotype.Component;
&nbsp;import survivor.ws.GameWs;
&nbsp;import lombok.Synchronized;
&nbsp;
&nbsp;@Component
&nbsp;@RequiredArgsConstructor
&nbsp;public class TickService
&nbsp;{
&nbsp;    private final MatchRuntimeRegistry registry;
&nbsp;    private final GameWs ws;
&nbsp;    private final survivor.match.MatchStore matchStore;
&nbsp;
&nbsp;    @Value(&quot;${tick.rate.hz:20}&quot;) private int hz;
&nbsp;
&nbsp;    @Scheduled(fixedRateString = &quot;#{1000/${tick.rate.hz:20}}&quot;)
&nbsp;    public void tickAll()
&nbsp;    {
<b class="fc">&nbsp;        var activeRuntimes = new java.util.ArrayList&lt;&gt;(registry.active()); // Create snapshot copy</b>
&nbsp;        
<b class="fc">&nbsp;        if (activeRuntimes.size() &gt; 0) {</b>
<b class="fc">&nbsp;            System.out.println(&quot;TICK #&quot; + System.currentTimeMillis() + &quot; - Processing &quot; + activeRuntimes.size() + &quot; runtime(s)&quot;);</b>
&nbsp;        }
&nbsp;        
<b class="fc">&nbsp;        for (var rt : activeRuntimes)</b>
&nbsp;        {
&nbsp;            // Double-check runtime still exists in registry (defensive)
<b class="pc">&nbsp;            if (registry.get(rt.id()).isEmpty()) {</b>
<b class="nc">&nbsp;                System.out.println(&quot;  -&gt; Skipping match &quot; + rt.id() + &quot; - removed from registry&quot;);</b>
&nbsp;                continue;
&nbsp;            }
&nbsp;            
&nbsp;            // Skip runtimes that have been manually stopped (ended flag set)
&nbsp;            // Automatic match end removes runtime from registry, so this mainly handles manual stops
<b class="fc">&nbsp;            if (rt.isEnded()) {</b>
<b class="fc">&nbsp;                System.out.println(&quot;  -&gt; Skipping match &quot; + rt.id() + &quot; - marked as ended&quot;);</b>
&nbsp;                continue;
&nbsp;            }
&nbsp;            
<b class="fc">&nbsp;            var delta = rt.tick();</b>
<b class="fc">&nbsp;            dispatch(rt, delta);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void dispatch(MatchRuntime rt, MatchDelta delta) {
&nbsp;        // Don&#39;t dispatch anything if runtime has been stopped
<b class="pc">&nbsp;        if (rt.isEnded()) {</b>
<b class="nc">&nbsp;            System.out.println(&quot;  -&gt; dispatch() skipping match &quot; + rt.id() + &quot; - ended=true&quot;);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;        
&nbsp;        // Double-check runtime is still in registry (defensive check)
<b class="pc">&nbsp;        if (registry.get(rt.id()).isEmpty()) {</b>
<b class="nc">&nbsp;            System.out.println(&quot;  -&gt; dispatch() skipping match &quot; + rt.id() + &quot; - not in registry&quot;);</b>
&nbsp;            return;
&nbsp;        }
&nbsp;        
&nbsp;        // events (damage / deaths) - wrap in proper format for frontend
&nbsp;        // Broadcast these BEFORE handling match end so clients receive death notifications
<b class="fc">&nbsp;        if (!delta.events().damages().isEmpty()) {</b>
<b class="fc">&nbsp;            java.util.Map&lt;String, Object&gt; damageEvent = new java.util.HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;            damageEvent.put(&quot;event&quot;, &quot;DAMAGE&quot;);</b>
<b class="fc">&nbsp;            damageEvent.put(&quot;damages&quot;, delta.events().damages());</b>
<b class="fc">&nbsp;            ws.game(rt.id(), damageEvent);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!delta.events().deaths().isEmpty()) {</b>
<b class="fc">&nbsp;            java.util.Map&lt;String, Object&gt; deathEvent = new java.util.HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;            deathEvent.put(&quot;event&quot;, &quot;DEATH&quot;);</b>
<b class="fc">&nbsp;            deathEvent.put(&quot;deaths&quot;, delta.events().deaths());</b>
<b class="fc">&nbsp;            ws.game(rt.id(), deathEvent);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Always send snapshots during gameplay (even if empty) so frontend receives state updates
&nbsp;        // Aggregate per-player snapshots into unified format for broadcast
<b class="fc">&nbsp;        if (!delta.snapshots().isEmpty()) {</b>
<b class="fc">&nbsp;            java.util.Map&lt;String, Object&gt; baseSnapshot = aggregateSnapshots(delta.snapshots());</b>
<b class="fc">&nbsp;            java.util.Map&lt;String, Object&gt; unifiedSnapshot = new java.util.HashMap&lt;&gt;(baseSnapshot);</b>
&nbsp;            // Attach current world level so frontend can display it in the HUD.
<b class="fc">&nbsp;            unifiedSnapshot.put(&quot;worldLevel&quot;, rt.getCurrentWorldLevel());</b>
<b class="fc">&nbsp;            ws.game(rt.id(), unifiedSnapshot);</b>
&nbsp;        } else {
&nbsp;            // Send empty snapshot if match is started but no snapshots generated yet
&nbsp;            // This ensures frontend receives periodic updates even during initialization
&nbsp;            // Don&#39;t send snapshots if runtime has been manually stopped
<b class="pc">&nbsp;            if (rt.isStarted() &amp;&amp; !rt.isEnded()) {</b>
<b class="nc">&nbsp;                java.util.Map&lt;String, Object&gt; emptySnapshot = new java.util.HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;                emptySnapshot.put(&quot;players&quot;, java.util.List.of());</b>
<b class="nc">&nbsp;                emptySnapshot.put(&quot;enemies&quot;, java.util.List.of());</b>
<b class="nc">&nbsp;                emptySnapshot.put(&quot;worldLevel&quot;, rt.getCurrentWorldLevel());</b>
<b class="nc">&nbsp;                ws.game(rt.id(), emptySnapshot);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // ---- NEW: XP + Upgrade events ----
<b class="fc">&nbsp;        var players = rt.getPlayers().values();</b>
<b class="fc">&nbsp;        for (survivor.model.PlayerState p : players) {</b>
<b class="pc">&nbsp;            if (p == null || p.isDead()) continue;</b>
&nbsp;
&nbsp;            // A. XP update
<b class="fc">&nbsp;            var xpEvent = new java.util.HashMap&lt;String, Object&gt;();</b>
<b class="fc">&nbsp;            xpEvent.put(&quot;event&quot;, &quot;xpUpdate&quot;);</b>
<b class="fc">&nbsp;            xpEvent.put(&quot;playerId&quot;, p.id());</b>
<b class="fc">&nbsp;            xpEvent.put(&quot;xp&quot;, p.getXp());</b>
<b class="fc">&nbsp;            xpEvent.put(&quot;level&quot;, p.getLevel());</b>
<b class="fc">&nbsp;            xpEvent.put(&quot;xpToNext&quot;, p.getXpToNext());</b>
<b class="fc">&nbsp;            ws.game(rt.id(), xpEvent);</b>
&nbsp;
&nbsp;            // B. Upgrade choices (while player is in choosingUpgrade state)
<b class="fc">&nbsp;            if (p.isChoosingUpgrade()</b>
<b class="pc">&nbsp;                    &amp;&amp; p.getCurrentUpgradeOptions() != null</b>
<b class="pc">&nbsp;                    &amp;&amp; !p.getCurrentUpgradeOptions().isEmpty()) {</b>
&nbsp;
<b class="fc">&nbsp;                var upgEvent = new java.util.HashMap&lt;String, Object&gt;();</b>
<b class="fc">&nbsp;                upgEvent.put(&quot;event&quot;, &quot;upgradeOptions&quot;);</b>
<b class="fc">&nbsp;                upgEvent.put(&quot;playerId&quot;, p.id());</b>
<b class="fc">&nbsp;                upgEvent.put(&quot;level&quot;, p.getLevel());</b>
&nbsp;
<b class="fc">&nbsp;                var options = p.getCurrentUpgradeOptions()</b>
<b class="fc">&nbsp;                        .stream()</b>
<b class="fc">&nbsp;                        .map(Enum::name) // &quot;DAMAGE_UP&quot;, &quot;ATKSPEED_UP&quot;, &quot;MAX_HP_UP&quot;</b>
<b class="fc">&nbsp;                        .toList();</b>
&nbsp;
<b class="fc">&nbsp;                upgEvent.put(&quot;options&quot;, options);</b>
<b class="fc">&nbsp;                ws.game(rt.id(), upgEvent);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Handle match end AFTER broadcasting events
&nbsp;        // This ensures clients receive death notifications before match end
<b class="pc">&nbsp;        if (delta.shouldEnd()) {</b>
<b class="nc">&nbsp;            handleMatchEnd(rt);</b>
&nbsp;            return; // Exit immediately after handling match end
&nbsp;        }
&nbsp;
&nbsp;        // later (with auth), switch to per-user queues:
&nbsp;        // delta.snapshots().forEach((accountId, snap) -&gt; ws.toPlayer(rt.id(), accountId, snap));
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Aggregate per-player snapshots into unified format for broadcast.
&nbsp;     * Collects all unique players and enemies from all per-player snapshots.
&nbsp;     * This provides a single unified snapshot that all players receive via broadcast.
&nbsp;     * 
&nbsp;     * When switching to per-user queues, this aggregation can be removed and
&nbsp;     * individual per-player snapshots can be sent directly to each player.
&nbsp;     */
&nbsp;    private java.util.Map&lt;String, Object&gt; aggregateSnapshots(java.util.Map&lt;Integer, SnapshotBuilder.PlayerSnapshot&gt; snapshots) {
<b class="fc">&nbsp;        java.util.Map&lt;Integer, SnapshotBuilder.EntityView&gt; playersMap = new java.util.HashMap&lt;&gt;();</b>
<b class="fc">&nbsp;        java.util.Map&lt;Integer, SnapshotBuilder.EntityView&gt; enemiesMap = new java.util.HashMap&lt;&gt;();</b>
&nbsp;
&nbsp;        // Aggregate entities from all player snapshots
<b class="fc">&nbsp;        for (var playerSnapshot : snapshots.values()) {</b>
<b class="fc">&nbsp;            for (var entity : playerSnapshot.entities()) {</b>
<b class="fc">&nbsp;                if (&quot;player&quot;.equals(entity.type())) {</b>
&nbsp;                    // Players are always included (use putIfAbsent to avoid duplicates)
<b class="fc">&nbsp;                    playersMap.putIfAbsent(entity.id(), entity);</b>
<b class="pc">&nbsp;                } else if (&quot;enemy&quot;.equals(entity.type())) {</b>
&nbsp;                    // For enemies, replace &quot;enemy&quot; type with actual enemy type (BUMPER, SWIPER)
&nbsp;                    // Frontend expects enemy type in the &quot;type&quot; field
<b class="fc">&nbsp;                    SnapshotBuilder.EntityView enemyWithType = new SnapshotBuilder.EntityView(</b>
<b class="pc">&nbsp;                        entity.enemyType() != null ? entity.enemyType() : &quot;ENEMY&quot;,  // Use enemyType as type</b>
<b class="fc">&nbsp;                        entity.id(),</b>
<b class="fc">&nbsp;                        entity.x(),</b>
<b class="fc">&nbsp;                        entity.y(),</b>
<b class="fc">&nbsp;                        entity.hp(),</b>
<b class="fc">&nbsp;                        entity.enemyType()  // Keep enemyType field as well</b>
&nbsp;                    );
<b class="fc">&nbsp;                    enemiesMap.putIfAbsent(entity.id(), enemyWithType);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        // Convert maps to lists for JSON serialization
<b class="fc">&nbsp;        java.util.List&lt;SnapshotBuilder.EntityView&gt; playersList = new java.util.ArrayList&lt;&gt;(playersMap.values());</b>
<b class="fc">&nbsp;        java.util.List&lt;SnapshotBuilder.EntityView&gt; enemiesList = new java.util.ArrayList&lt;&gt;(enemiesMap.values());</b>
&nbsp;
<b class="fc">&nbsp;        return java.util.Map.of(</b>
<b class="fc">&nbsp;                &quot;players&quot;, playersList,</b>
<b class="fc">&nbsp;                &quot;enemies&quot;, enemiesList</b>
&nbsp;        );
&nbsp;    }
&nbsp;
&nbsp;    @Synchronized
<b class="nc">&nbsp;    private void handleMatchEnd(MatchRuntime rt) {</b>
&nbsp;        // Prevent multiple calls - mark as ended immediately
<b class="nc">&nbsp;        if (rt.isEnded()) {</b>
<b class="nc">&nbsp;            System.out.println(&quot;  -&gt; handleMatchEnd() skipping match &quot; + rt.id() + &quot; - already ended&quot;);</b>
<b class="nc">&nbsp;            return;</b>
&nbsp;        }
&nbsp;        
&nbsp;        // Remove from registry FIRST to prevent any further ticks from processing this runtime
&nbsp;        // This is critical to prevent race conditions and repeated calls
<b class="nc">&nbsp;        registry.end(rt.id());</b>
&nbsp;        
&nbsp;        // Mark runtime as ended to prevent any remaining operations
<b class="nc">&nbsp;        rt.stop();</b>
&nbsp;        
&nbsp;        try {
&nbsp;            // Safely get players - check for null
<b class="nc">&nbsp;            var players = rt.getPlayers();</b>
<b class="nc">&nbsp;            if (players == null) {</b>
<b class="nc">&nbsp;                System.err.println(&quot;  -&gt; Warning: players map is null for match &quot; + rt.id());</b>
<b class="nc">&nbsp;                return;</b>
&nbsp;            }
&nbsp;            
&nbsp;            // Find the winner (last player alive)
<b class="nc">&nbsp;            Integer winnerId = players.values().stream()</b>
<b class="nc">&nbsp;                    .filter(p -&gt; p != null &amp;&amp; !p.isDead())</b>
<b class="nc">&nbsp;                    .map(survivor.model.PlayerState::id)</b>
<b class="nc">&nbsp;                    .findFirst()</b>
<b class="nc">&nbsp;                    .orElse(null);</b>
&nbsp;
&nbsp;            // Mark match as ended in database
<b class="nc">&nbsp;            matchStore.markEnded(rt.id(), winnerId, java.time.Instant.now());</b>
&nbsp;
&nbsp;            // Collect results from gameplay (coins earned from enemy drops, score from kills/time)
<b class="nc">&nbsp;            var results = players.values().stream()</b>
<b class="nc">&nbsp;                    .filter(p -&gt; p != null)</b>
<b class="nc">&nbsp;                    .map(p -&gt; {</b>
<b class="nc">&nbsp;                        long timeAlive = rt.getStartTime() &gt; 0 </b>
<b class="nc">&nbsp;                            ? System.currentTimeMillis() - rt.getStartTime() </b>
<b class="nc">&nbsp;                            : 0;</b>
<b class="nc">&nbsp;                        return new survivor.ws.dto.ParticipantResult(</b>
<b class="nc">&nbsp;                                p.id(), </b>
<b class="nc">&nbsp;                                p.getScore(), // score earned during gameplay</b>
<b class="nc">&nbsp;                                p.getCoinsEarned(), // coins from enemy drops during gameplay</b>
<b class="nc">&nbsp;                                0, // kills (not tracked yet)</b>
<b class="nc">&nbsp;                                timeAlive // time alive</b>
&nbsp;                        );
&nbsp;                    })
<b class="nc">&nbsp;                    .toList();</b>
&nbsp;
&nbsp;            // Persist results to UserProgress (only if we have results)
<b class="nc">&nbsp;            if (!results.isEmpty()) {</b>
<b class="nc">&nbsp;                matchStore.writeResults(rt.id(), results);</b>
&nbsp;
&nbsp;                // Broadcast match end to all players
<b class="nc">&nbsp;                ws.game(rt.id(), java.util.Map.of(</b>
<b class="nc">&nbsp;                        &quot;event&quot;, &quot;MATCH_ENDED&quot;,</b>
<b class="nc">&nbsp;                        &quot;winnerId&quot;, winnerId != null ? winnerId : -1,</b>
<b class="nc">&nbsp;                        &quot;results&quot;, results</b>
&nbsp;                ));
&nbsp;            } else {
&nbsp;                // Still broadcast match end even if no results
<b class="nc">&nbsp;                ws.game(rt.id(), java.util.Map.of(</b>
<b class="nc">&nbsp;                        &quot;event&quot;, &quot;MATCH_ENDED&quot;,</b>
<b class="nc">&nbsp;                        &quot;winnerId&quot;, winnerId != null ? winnerId : -1,</b>
<b class="nc">&nbsp;                        &quot;results&quot;, java.util.List.of()</b>
&nbsp;                ));
&nbsp;            }
&nbsp;            
<b class="nc">&nbsp;            System.out.println(&quot;  -&gt; Match &quot; + rt.id() + &quot; ended successfully. Winner: &quot; + winnerId);</b>
&nbsp;
&nbsp;        } catch (Exception e) {
&nbsp;            // Better error logging to identify the actual issue
<b class="nc">&nbsp;            System.err.println(&quot;Error handling match end for match &quot; + rt.id() + &quot;:&quot;);</b>
<b class="nc">&nbsp;            System.err.println(&quot;  Exception type: &quot; + e.getClass().getName());</b>
<b class="nc">&nbsp;            System.err.println(&quot;  Message: &quot; + (e.getMessage() != null ? e.getMessage() : &quot;(null)&quot;));</b>
<b class="nc">&nbsp;            System.err.println(&quot;  Stack trace:&quot;);</b>
<b class="nc">&nbsp;            e.printStackTrace();</b>
&nbsp;            
&nbsp;            // Runtime is already removed from registry, so we don&#39;t need to remove it again
&nbsp;            // Just log the error - the match end cleanup has already happened
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-12-08 17:10</div>
</div>
</body>
</html>
